# 3 モデルスペック
## モデルスペックを作成する。
1. `$ bin/rails g rspec:model user`でrspec:model ジェネレータを作成する。 [![Image from Gyazo](https://i.gyazo.com/3bce7fad67def0e0675c57ccb65f0685.png)](https://gyazo.com/3bce7fad67def0e0675c57ccb65f0685)
2. ここで`$  bin/rspec`をすると [![Image from Gyazo](https://i.gyazo.com/2c9cfc8a7ee53bd9fab274c84501c271.png)](https://gyazo.com/2c9cfc8a7ee53bd9fab274c84501c271)   
  上記は1つのexampleがあり、1つ保留していることを表す。
3. exampleを記述する。 [![Image from Gyazo](https://i.gyazo.com/705356caa9a20a3a9f77938db78ef515.png)](https://gyazo.com/705356caa9a20a3a9f77938db78ef515) 
4. ここで`$  bin/rspec`をすると  [![Image from Gyazo](https://i.gyazo.com/23ca7d7f4662e4a52400c4d47131c331.png)](https://gyazo.com/23ca7d7f4662e4a52400c4d47131c331)
    上記は6つのexampleがあり、6つ保留していることを表す。
## RSpecの構文
- should構文は動作はするが非推奨。
- 新しいecpect()構文が無難。
[![Image from Gyazo](https://i.gyazo.com/eb5644750f64ba4d110902b2cbe9fd01.png)](https://gyazo.com/eb5644750f64ba4d110902b2cbe9fd01)
-  上図はbe_valid という RSpec のマッチャを使って、モデルが有効な状態を理解できているかどうかを検証している。作成したオブジェクトを expect に渡して、マッチャと比較している。
-  ここで`$ bin/rspec`すると[![Image from Gyazo](https://i.gyazo.com/f728990847f3c277e6b60ee254eb4618.png)](https://gyazo.com/f728990847f3c277e6b60ee254eb4618) これは1つの example がパスしたと表示となる。
## バリデーションをテストする。
[![Image from Gyazo](https://i.gyazo.com/593c813dd41c42528bbc3c9c8a9c5b8e.png)](https://gyazo.com/593c813dd41c42528bbc3c9c8a9c5b8e)
- 上図はfirst_name には明示的に nil をセットに対して valid? メソッドを呼び出すと有効（valid）に ならず 、ユーザーの first_name 属性にエラーメッセージが付いていることを 期待（expect） している。
- includeマッチャはある値が存在するかどうかをチェックするメソッド。
- しかしまだ、誤判定の可能性がある！！
  - 確かめる方法
    1. to を to_not に変えてエクスペクテーションを反転させる。
    2. アプリケーションを開いてバリデーションをコメントアウトする。
 これでテストが**失敗**すれば、正しいテストが書けていると判断できる！　  
 - この後Projectモデルでもテストを作成（本書で確認）
  - ここではユーザーを create してデータベースに保存している点に注意。これはユーザーをテスト対象のプロジェクトに割り当てる必要があるため。
  - もし数値しか受け付けない属性のバリデーションがあるなら、文字列を渡すことや、もし4文字から8文字の文字列を要求するバリデーションがあるなら、3文字と9文字の文字列を渡してテストの確認をするようにせよ！！。

## インスタンスメソッドをテストする
- RSpec で等値のエクスペクテーションを書くときは == ではなく eq を使う。

## クラスメソッドとスコープをテストする
- ここでは 
```
expect(Note.search("first")).to include(note1, note3)
31 expect(Note.search("first")).to_not include(note2)
```
でnote1,note3が検索結果に含まれて、note2が含まれないことを2つに分けて記述している点に注目！

## 失敗をテストする
