## 💬 はじめに

本番環境で **Railsのコンテナが突然落ちる** という事象が発生しました。  
AWSのコンソールを見ると、ログにこう出ていました。
```
  OutOfMemoryError: Container killed due to memory usage
```


CPUはそこまで上がっていないのに、**メモリ使用率が常に100%近く！**

しばらく操作しない状態からアクセスすると、
**サーバーが落ちてECSでコンテナが再デプロイしている！！** 

これは明らかに異常です。

調査を進めると、**Solid Queue の並列設定が“盛りすぎ”** になっており、  
ワーカーが過剰にスレッドを確保してメモリを食い潰していることが原因でした。

今回は、ディスパッチャとワーカーの並列度を絞り込み、  
Puma側のスレッドも明示することで安定化した経緯をまとめます。

## 🧩 背景と課題

もともとの設定は以下のようなものでした。

- `batch_size: 1000`, `threads: 5`, `processes: 2` と高めの並列設定  
- 実際のジョブ負荷は軽く、I/O待ち中心  
- `WEB_CONCURRENCY` や `RAILS_MAX_THREADS` が未設定のまま起動しており  
  **Pumaとの整合性が取れていない状態**

この状態だと、Solid Queue のワーカーが  
**複数スレッド分のメモリを同時確保し続ける**ため、  
使用率が徐々に上昇 → 解放が追いつかず OOMKill に至ります。

## 🔧 Solid Queue 設定の見直し

### **変更内容**

```yaml
# config/solid_queue.yml（一部抜粋）
production:
  <<: *default
  dispatchers:
    - polling_interval: 1
      batch_size: 200   # 1000 → 200 に縮小

  workers:
    - queues: ["default", "mailers"]
      threads: 1        # 5 → 1
      processes: 1      # 2 → 1

    - queues: ["urgent"]
      threads: 1        # 3 → 1
      processes: 1
```

### **ポイント**

| 項目 | 変更理由 |
|------|-----------|
| `batch_size: 200` | 一度に大量のジョブをフェッチせず、**小刻みに処理してメモリ使用量を均す** |
| `threads / processes: 1` | スレッドの競合を防ぎ、**プロセスごとのメモリ確保を最小化** |
| `urgent`キューも統一 | 緊急ジョブも重くないため、**全体をシンプルな構成に揃える** |

## 🧠 Puma 側のデフォルトも明示

Solid Queueの並列度を落としたなら、  
**Webプロセス（Puma）側のスレッド数も明示**しておくとより安定します。

```bash
# entrypoint.prod.sh（一部抜粋）
export WEB_CONCURRENCY=${WEB_CONCURRENCY:-1}
export RAILS_MAX_THREADS=${RAILS_MAX_THREADS:-2}
```

これにより：

- インフラ側で値を渡さなくても最低限の構成で起動
- Solid Queueとの整合性が明確に
- 「Railsがどの程度の並列処理を想定しているか」が一目で分かるように

## 📊 効果（初期観測）

### **期待していたこと**

- 不要な並列処理を削減し、**メモリ使用量を平準化**  
- Solid Queueワーカーの暴走を防止し、**コンテナ落ちを回避**  
- Puma側との整合性を確保して、全体負荷を安定化  

### **実際の初期観測**

- 本番環境で **メモリ使用率が最大100% → 約45%に低下**  
- コンテナ再起動（OOMKill）が発生しなくなった

## 🧭 今回の学び

- **「とりあえずスレッド増やす」は危険。** メモリを想定以上に消費する  
- ワークロードに合わせた**batchサイズと並列度の設計**が大切  
- EntryPointなどのスクリプトにも**デフォルトを明示**しておくと、再現性が高まる  
- Solid Queueは設定がシンプルだからこそ、**小さな調整が効く**  

## 💬 おわりに

今回のOutOfMemoryErrorは、「負荷ではなく設定」が原因でした。  
Solid Queueの並列度を見直すだけで、  
コンテナの安定性が大きく改善することを実感しました。

今後は、ジョブ種別ごとにメトリクスを細分化して、  
メモリ消費の傾向を継続的に監視していく予定です。

同じように「**Solid Queueを導入したらメモリが膨らんで落ちる…**」  
という悩みを抱えている方の参考になれば嬉しいです。
